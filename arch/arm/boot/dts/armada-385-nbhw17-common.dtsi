/*
 * Device Tree file for the NetModule NBHW17 (NB2800)
 *
 * Copyright (C) 2017 NetModule
 *
 * Stefan Eichenberger <stefan.eichenberger@netmodule.com>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 */

#include <dt-bindings/gpio/gpio.h>
#include "armada-385.dtsi"

/ {
	compatible = "marvell,a385-nbhw17", "marvell,armada385", "marvell,armada380";

	chosen {
		bootargs = "console=ttyS0,115200 earlyprintk";
	};

	memory {
		device_type = "memory";
		reg = <0x00000000 0x40000000>; /* 1 GB */
	};

	soc {
		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000
			  MBUS_ID(0x09, 0x19) 0 0xf1100000 0x10000 /* CESA 0 SRAM */
			  MBUS_ID(0x09, 0x15) 0 0xf1110000 0x10000 /* CESA 1 SRAM */
			  MBUS_ID(0x01, 0x3e) 0 0xfd000000 0x20000>; /* Devbus CS0 */

		fpga: devbus-cs0 {
			status = "okay";
			ranges = <0 MBUS_ID(0x01, 0x3e) 0 0x20000>;
			devbus,keep-config;
		};

		internal-regs {
			vcc3v3: fixedregulator@0 {
				compatible = "regulator-fixed";
				regulator-min-microvolt = <2048000>;
				regulator-max-microvolt = <2048000>;
			};

			pinctrl {
				pic_pins: pic-pins-0 {
					marvell,pins = "mpp20", "mpp24", "mpp27", "mpp29", "mpp41", "mpp44",
					"mpp47", "mpp51", "mpp56";
					marvell,function = "gpio";
				};
			};
		};

		gpio-keys {
			compatible = "gpio-keys";

			reset-button {
				label = "Reset button";
					gpios = <&gpio1 24 0>;
					linux,code = <0x198>; /* KEY_RESTART */
			};
		};
	};
};

&watchdog {
	status = "okay";
	interrupts = <&mpic 96>;
	timeout-sec = <10>;
};

&cesa {
	status = "okay";
};

&uart0 {
	status = "okay";
};

&uart1 {
	status = "okay";
};

&i2c0 {
	status = "okay";
	clock-frequency = <100000>;

	lm75@48 {
		compatible = "national,lm75";
		reg = <0x48>;
	};

	eeprom_cm@50 {
		compatible = "at24,24c64";
		reg = <0x50>;
	};

	adc_power@6bc {
		compatible = "maxim,max11647";
		reg = <0x36>;
		#io-channel-cells = <1>;
		vcc-supply = <&vcc3v3>;
	};

	rtc@68 {
		compatible = "dallas,ds1339";
		reg = <0x68>;
	};
};

&i2c1 {
	status = "disabled";
};

&mdio {
	status = "okay";
	pinctrl-names = "default";

	phy0: ethernet-phy@0 {
		reg = <0>;
		/* Set blink mode */
		marvell,reg-init = <3 16 0x0 0x1032
							3 17 0x0 0x4405
							3 18 0x0 0x4A08>;
	};

	phy1: ethernet-phy@1 {
		reg = <1>;
		/* Set blink mode */
		marvell,reg-init = <3 16 0x0 0x1032
							3 17 0x0 0x4405
							3 18 0x0 0x4A08>;
	};
};

&eth0 {
	status = "disabled";
	phy-mode = "rgmii";
};

&eth1 {
	status = "disabled";
	phy-mode = "sgmii";
	phy = <&phy0>;
};

&eth2 {
	status = "disabled";
	phy-mode = "sgmii";
	phy = <&phy1>;
};

&ahci0 {
	status = "okay";
};

// Never ever enable this SATA controller on A385/A380 !
&ahci1 {
	status = "disabled";
};

&usb0 {
	status = "okay";
};

&usb3_0 {
	status = "okay";
};

&usb3_1 {
	status = "okay";
};

&sdhci {
	broken-cd;
	wp-inverted;
	no-1-8-v;
	bus-width = <8>;
	status = "okay";
};

&pciec {
	status = "okay";
};

/*
 * The two PCIe units are accessible through
 * standard PCIe slots on the board.
 */
&pcie3 {
	/* Port 2, Lane 0 */
	status = "okay";
};

&pcie1 {
	/* Port 0, Lane 0 */
	status = "okay";
};

&fpga {
	gpio_output1: gpio@08 {
		compatible = "wd,mbl-gpio";
		reg-names = "dat";
		reg = <0x08 2>;
		gpio-controller;
		#gpio-cells = <2>;
		gpio-line-names =
			"HOLD_PWR_ON", "EN_GPS_ANT",
			"EN_MDIO_PHY~", "EN_MDIO_EXT~",
			"EN_SATA_PWR", "SERDES_SEL",
			"SERDES_EN~", "RST_EXT~", 
			"RST_EXT_ETH~", "EXT_RST_EN", 
			"", "",
			"", "", "", "";
	};

	gpio_leds: gpio@20 {
		compatible = "wd,mbl-gpio";
		reg-names = "dat";
		reg = <0x20 2>;
		gpio-controller;
		#gpio-cells = <2>;
	};

	gpio_pcie_rst: gpio@30 {
		compatible = "wd,mbl-gpio";
		reg-names = "dat";
		reg = <0x30 2>;
		gpio-controller;
		#gpio-cells = <2>;
		gpio-line-names =
			"PCIE1 RST~", "PCIE2 RST~",
			"PCIE3 RST~", "PCIE4 RST~",
			"PCIE5 RST~", "PCIE6 RST~",
			"", "",
			"", "", "", "",
			"", "", "", "";
	};

	gpio_pcie_pwr: gpio@32 {
		compatible = "wd,mbl-gpio";
		reg-names = "dat";
		reg = <0x32 2>;
		gpio-controller;
		#gpio-cells = <2>;
		gpio-line-names =
			"PCIE1 PWR", "PCIE2 PWR",
			"PCIE3 PWR", "PCIE4 PWR",
			"PCIE5 PWR", "PCIE6 PWR",
			"", "",
			"", "", "", "",
			"", "", "", "";
	};

	gpio_sim_ctl: gpio@40 {
		compatible = "wd,mbl-gpio";
		reg-names = "dat";
		reg = <0x40 2>;
		gpio-controller;
		#gpio-cells = <2>;
		gpio-line-names =
			"SIM1-SEL0", "SIM1-SEL1", "SIM1-SEL3", "",  
			"SIM2-SEL0", "SIM2-SEL1", "SIM2-SEL3", "",  
			"SIM3-SEL0", "SIM3-SEL1", "SIM3-SEL3", "",  
			"SIM4-SEL0", "SIM4-SEL1", "SIM4-SEL3", "";
	};

	leds {
		compatible = "gpio-leds";
		status-green {
			label = "status:green";
			gpios = <&gpio_leds 0 0>;
		};
		status-red {
			label = "status:red";
			gpios = <&gpio_leds 1 0>;
		};
		ind1-green {
			label = "ind1:green";
			gpios = <&gpio_leds 2 0>;
		};
		ind1-red {
			label = "ind1:red";
			gpios = <&gpio_leds 3 0>;
		};
		ind2-green {
			label = "ind2:green";
			gpios = <&gpio_leds 4 0>;
		};
		ind2-red {
			label = "ind2:red";
			gpios = <&gpio_leds 5 0>;
		};
		ind3-green {
			label = "ind3:green";
			gpios = <&gpio_leds 6 0>;
		};
		ind3-red {
			label = "ind3:red";
			gpios = <&gpio_leds 7 0>;
		};
		ind4-green {
			label = "ind4:green";
			gpios = <&gpio_leds 8 0>;
		};
		ind4-red {
			label = "ind4:red";
			gpios = <&gpio_leds 9 0>;
		};
		ind5-green {
			label = "ind5:green";
			gpios = <&gpio_leds 10 0>;
		};
		ind5-red {
			label = "ind5:red";
			gpios = <&gpio_leds 11 0>;
		};
		ind6-green {
			label = "ind6:green";
			gpios = <&gpio_leds 12 0>;
		};
		ind6-red {
			label = "ind6:red";
			gpios = <&gpio_leds 13 0>;
		};
	};

	/* LEDs are not the correct desginator for this.
	 * But there is no driver that actually has the
	 * correct name for our purpose. For now the LED
	 * driver does exactly what we want to do...
	 */ 
	output1 {
		compatible = "gpio-leds";
		hold-pwr-on {
			label = "out:hold_pwr_on";
			gpios = <&gpio_output1 0 0>;
			default-state = "keep";
		};

		en-gps-ant {
			label = "out:en_gps_ant";
			gpios = <&gpio_output1 1 0>;
			default-state = "keep";
		};

		en_mdio_phy {
			label = "out:en_mdio_phy";
			gpios = <&gpio_output1 2 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		en_mdio_ext {
			label = "out:en_mdio_ext";
			gpios = <&gpio_output1 3 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		en_sata_pwr {
			label = "out:en_sata_pwr";
			gpios = <&gpio_output1 4 0>;
			default-state = "keep";
		};

		serdes_sel {
			label = "out:serdes_sel";
			gpios = <&gpio_output1 5 0>;
			default-state = "keep";
		};

		serdes_en {
			label = "out:serdes_en";
			gpios = <&gpio_output1 6 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		rst_ext {
			label = "out:rst_ext";
			gpios = <&gpio_output1 7 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		rst_ext_eth {
			label = "out:rst_ext_eth";
			gpios = <&gpio_output1 8 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		ext_rst_en {
			label = "out:ext_rst_en";
			gpios = <&gpio_output1 9 0>;
			default-state = "keep";
		};

	};

	simctl {
		compatible = "gpio-leds";
		sim1-sel0 {
			label = "sim1:sel0";
			gpios = <&gpio_sim_ctl 0 0>;
			default-state = "keep";
		};

		sim1-sel1 {
			label = "sim1:sel1";
			gpios = <&gpio_sim_ctl 1 0>;
			default-state = "keep";
		};

		sim1-sel2 {
			label = "sim1:sel2";
			gpios = <&gpio_sim_ctl 2 0>;
			default-state = "keep";
		};

		sim2-sel0 {
			label = "sim2:sel0";
			gpios = <&gpio_sim_ctl 4 0>;
			default-state = "keep";
		};

		sim2-sel1 {
			label = "sim2:sel1";
			gpios = <&gpio_sim_ctl 5 0>;
			default-state = "keep";
		};

		sim2-sel2 {
			label = "sim2:sel2";
			gpios = <&gpio_sim_ctl 6 0>;
			default-state = "keep";
		};

		sim3-sel0 {
			label = "sim3:sel0";
			gpios = <&gpio_sim_ctl 8 0>;
			default-state = "keep";
		};

		sim3-sel1 {
			label = "sim3:sel1";
			gpios = <&gpio_sim_ctl 9 0>;
			default-state = "keep";
		};

		sim3-sel2 {
			label = "sim3:sel2";
			gpios = <&gpio_sim_ctl 10 0>;
			default-state = "keep";
		};

		sim4-sel0 {
			label = "sim4:sel0";
			gpios = <&gpio_sim_ctl 12 0>;
			default-state = "keep";
		};

		sim4-sel1 {
			label = "sim4:sel1";
			gpios = <&gpio_sim_ctl 13 0>;
			default-state = "keep";
		};

		sim4-sel2 {
			label = "sim4:sel2";
			gpios = <&gpio_sim_ctl 14 0>;
			default-state = "keep";
		};
	};

	pciepwr {
		compatible = "gpio-leds";
		pcie1-pwr {
			label = "pcie1:pwr";
			gpios = <&gpio_pcie_pwr 0 0>;
			default-state = "keep";
		};

		pcie2-pwr {
			label = "pcie2:pwr";
			gpios = <&gpio_pcie_pwr 1 0>;
			default-state = "keep";
		};
	
		pcie3-pwr {
			label = "pcie3:pwr";
			gpios = <&gpio_pcie_pwr 2 0>;
			default-state = "keep";
		};
	
		pcie4-pwr {
			label = "pcie4:pwr";
			gpios = <&gpio_pcie_pwr 3 0>;
			default-state = "keep";
		};

		pcie5-pwr {
			label = "pcie5:pwr";
			gpios = <&gpio_pcie_pwr 4 0>;
			default-state = "keep";
		};
	
		pcie6-pwr {
			label = "pcie6:pwr";
			gpios = <&gpio_pcie_pwr 5 0>;
			default-state = "keep";
		};

	};

	pcierst {
		compatible = "gpio-leds";
		pcie1-rst {
			label = "pcie1:rst";
			gpios = <&gpio_pcie_rst 0 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		pcie2-rst {
			label = "pcie2:rst";
			gpios = <&gpio_pcie_rst 1 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};
	
		pcie3-rst {
			label = "pcie3:rst";
			gpios = <&gpio_pcie_rst 2 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};
	
		pcie4-rst {
			label = "pcie4:rst";
			gpios = <&gpio_pcie_rst 3 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};

		pcie5-rst {
			label = "pcie5:rst";
			gpios = <&gpio_pcie_rst 4 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};
	
		pcie6-rst {
			label = "pcie6:rst";
			gpios = <&gpio_pcie_rst 5 GPIO_ACTIVE_LOW>;
			default-state = "keep";
		};
	};
};
